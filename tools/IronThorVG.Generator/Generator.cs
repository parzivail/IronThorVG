using System.Text;

internal static class Generator
{
	public static void WriteEnums(string path, HeaderModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine("namespace IronThorVG;");
		sb.AppendLine();

		foreach (var enumDef in model.Enums)
		{
			if (!string.IsNullOrWhiteSpace(enumDef.Summary))
			{
				sb.AppendLine("/// <summary>");
				sb.AppendLine($"/// {Escape(enumDef.Summary)}");
				sb.AppendLine($"/// Native: {enumDef.NativeName}");
				sb.AppendLine("/// </summary>");
			}

			if (enumDef.IsFlags)
			{
				sb.AppendLine("[System.Flags]");
			}

			sb.AppendLine($"public enum {enumDef.Name} : uint");
			sb.AppendLine("{");
			foreach (var value in enumDef.Values)
			{
				if (!string.IsNullOrWhiteSpace(value.Summary))
				{
					sb.AppendLine($"    /// <summary>{Escape(value.Summary)}</summary>");
				}

				sb.AppendLine($"    /// <remarks>Native: {value.NativeName}</remarks>");

				if (!string.IsNullOrWhiteSpace(value.Value))
				{
					sb.AppendLine($"    {value.Name} = {value.Value},");
				}
				else
				{
					sb.AppendLine($"    {value.Name},");
				}
			}

			sb.AppendLine("}");
			sb.AppendLine();
		}

		File.WriteAllText(path, sb.ToString());
	}

	public static void WriteStructs(string path, HeaderModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine("using System.Runtime.InteropServices;");
		sb.AppendLine();
		sb.AppendLine("namespace IronThorVG;");
		sb.AppendLine();

		foreach (var structDef in model.Structs)
		{
			if (!string.IsNullOrWhiteSpace(structDef.Summary))
			{
				sb.AppendLine("/// <summary>");
				sb.AppendLine($"/// {Escape(structDef.Summary)}");
				sb.AppendLine($"/// Native: {structDef.NativeName}");
				sb.AppendLine("/// </summary>");
			}

			sb.AppendLine("[StructLayout(LayoutKind.Sequential)]");
			sb.AppendLine($"public partial struct {structDef.Name}");
			sb.AppendLine("{");
			foreach (var field in structDef.Fields)
			{
				if (!string.IsNullOrWhiteSpace(field.Summary))
				{
					sb.AppendLine($"    /// <summary>{Escape(field.Summary)}</summary>");
				}

				var fieldName = NameMapper.ToFieldName(field.Name);
				if (string.IsNullOrEmpty(fieldName))
				{
					fieldName = field.Name;
				}

				sb.AppendLine($"    public {field.TypeName} {fieldName};");
			}

			sb.AppendLine("}");
			sb.AppendLine();
		}

		File.WriteAllText(path, sb.ToString());
	}

	public static void WriteNativeMethods(string path, HeaderModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine("using System.Runtime.CompilerServices;");
		sb.AppendLine("using System.Runtime.InteropServices;");
		sb.AppendLine("using IronThorVG;");
		sb.AppendLine("using IronThorVG.Native;");
		sb.AppendLine();
		sb.AppendLine("namespace IronThorVG.Native;");
		sb.AppendLine();
		sb.AppendLine("internal static partial class ThorVGNative");
		sb.AppendLine("{");

		foreach (var function in model.Functions)
		{
			WriteFunction(sb, function, model.Handles);
			sb.AppendLine();
		}

		sb.AppendLine("}");
		File.WriteAllText(path, sb.ToString());
	}

	private static void WriteFunction(StringBuilder sb, FunctionDefinition function, IReadOnlyList<HandleDefinition> handles)
	{
		if (!string.IsNullOrWhiteSpace(function.Summary))
		{
			sb.AppendLine("    /// <summary>");
			sb.AppendLine($"    /// {Escape(function.Summary)}");
			sb.AppendLine("    /// </summary>");
		}

		foreach (var param in function.Parameters)
		{
			if (!string.IsNullOrWhiteSpace(param.Summary))
			{
				sb.AppendLine($"    /// <param name=\"{param.Name}\">{Escape(param.Summary)}</param>");
			}
		}

		if (!string.IsNullOrWhiteSpace(function.Returns))
		{
			sb.AppendLine($"    /// <returns>{Escape(function.Returns)}</returns>");
		}

		sb.AppendLine("    [LibraryImport(ThorVGNative.LibraryName, StringMarshalling = StringMarshalling.Utf8)]");
		sb.AppendLine("    [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]");
		var returnType = TypeMapper.MapReturnType(function.ReturnType, handles);
		if (returnType == "bool")
		{
			sb.AppendLine("    [return: MarshalAs(UnmanagedType.I1)]");
		}

		sb.Append($"    internal static partial {returnType} {function.Name}(");

		for (var i = 0; i < function.Parameters.Count; i++)
		{
			if (i > 0)
			{
				sb.Append(", ");
			}

			var param = function.Parameters[i];
			var paramType = TypeMapper.MapParamType(param, handles);
			var prefix = GetParamPrefix(param, paramType);
			if (paramType == "string")
			{
				sb.Append("[MarshalAs(UnmanagedType.LPUTF8Str)] ");
			}
			else if (paramType == "bool")
			{
				sb.Append("[MarshalAs(UnmanagedType.I1)] ");
			}

			sb.Append(prefix);
			sb.Append(paramType);
			sb.Append(' ');
			sb.Append(param.Name);
		}

		sb.AppendLine(");");
	}

	private static string GetParamPrefix(ParameterDefinition param, string mappedType)
	{
		if (mappedType == "string")
		{
			return string.Empty;
		}

		if (mappedType == "byte[]")
		{
			return "[In] ";
		}

		if (param.Direction == ParamDirection.Out && !param.IsPointer)
		{
			return "out ";
		}

		if (param.Direction == ParamDirection.Out)
		{
			return "out ";
		}

		if (param.Direction == ParamDirection.InOut)
		{
			return "ref ";
		}

		if (param.IsPointer && param.IsConst && param.PointerDepth == 1 && mappedType != "nint")
		{
			return "in ";
		}

		return string.Empty;
	}

	private static string Escape(string value)
	{
		return value.Replace("&", "&amp;", StringComparison.Ordinal).Replace("<", "&lt;", StringComparison.Ordinal);
	}
}