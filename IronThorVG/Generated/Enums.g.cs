// <auto-generated />
namespace IronThorVG;

/// <summary>
/// Enumeration specifying the result from the APIs. All ThorVG APIs could potentially return one of the values in the list. Please note that some APIs may additionally specify the reasons that trigger their return values.
/// Native: Tvg_Result
/// </summary>
public enum Result : uint
{
    /// <summary>The value returned in case of a correct request execution.</summary>
    /// <remarks>Native: TVG_RESULT_SUCCESS</remarks>
    Success = 0,
    /// <summary>The value returned in the event of a problem with the arguments given to the API - e.g. empty paths or null pointers.</summary>
    /// <remarks>Native: TVG_RESULT_INVALID_ARGUMENT</remarks>
    InvalidArgument,
    /// <summary>The value returned in case the request cannot be processed - e.g. asking for properties of an object, which does not exist.</summary>
    /// <remarks>Native: TVG_RESULT_INSUFFICIENT_CONDITION</remarks>
    InsufficientCondition,
    /// <summary>The value returned in case of unsuccessful memory allocation.</summary>
    /// <remarks>Native: TVG_RESULT_FAILED_ALLOCATION</remarks>
    FailedAllocation,
    /// <summary>The value returned in the event of bad memory handling - e.g. failing in pointer releasing or casting</summary>
    /// <remarks>Native: TVG_RESULT_MEMORY_CORRUPTION</remarks>
    MemoryCorruption,
    /// <summary>The value returned in case of choosing unsupported engine features(options).</summary>
    /// <remarks>Native: TVG_RESULT_NOT_SUPPORTED</remarks>
    NotSupported,
    /// <summary>The value returned in all other cases.</summary>
    /// <remarks>Native: TVG_RESULT_UNKNOWN</remarks>
    Unknown = 255,
}

/// <summary>
/// Enumeration specifying the methods of combining the 8-bit color channels into 32-bit color.
/// Native: Tvg_Colorspace
/// </summary>
public enum Colorspace : uint
{
    /// <summary>The channels are joined in the order: alpha, blue, green, red. Colors are alpha-premultiplied.</summary>
    /// <remarks>Native: TVG_COLORSPACE_ABGR8888</remarks>
    Abgr8888 = 0,
    /// <summary>The channels are joined in the order: alpha, red, green, blue. Colors are alpha-premultiplied.</summary>
    /// <remarks>Native: TVG_COLORSPACE_ARGB8888</remarks>
    Argb8888,
    /// <summary>The channels are joined in the order: alpha, blue, green, red. Colors are un-alpha-premultiplied. (since 0.13)</summary>
    /// <remarks>Native: TVG_COLORSPACE_ABGR8888S</remarks>
    Abgr8888s,
    /// <summary>The channels are joined in the order: alpha, red, green, blue. Colors are un-alpha-premultiplied. (since 0.13)</summary>
    /// <remarks>Native: TVG_COLORSPACE_ARGB8888S</remarks>
    Argb8888s,
    /// <summary>Unknown channel data. This is reserved for an initial ColorSpace value. (since 1.0)</summary>
    /// <remarks>Native: TVG_COLORSPACE_UNKNOWN</remarks>
    Unknown = 255,
}

/// <summary>
/// Enumeration to specify rendering engine behavior. It attempts to optimize rendering performance by updating only the regions  of the canvas that have changed between frames (partial redraw). This can be highly effective in scenarios  where most of the canvas remains static and only small portions are updatedâ€”such as simple animations or GUI interactions. However, in complex scenes where a large portion of the canvas changes frequently (e.g., full-screen animations or heavy object movements), the overhead of tracking changes and managing update regions may outweigh the benefits, resulting in decreased performance compared to the default rendering mode. Thus, it is recommended to benchmark both modes in your specific use case to determine the optimal setting.
/// Native: Tvg_Engine_Option
/// </summary>
[System.Flags]
public enum EngineOptions : uint
{
    /// <summary>No engine options are enabled. This may be used to explicitly disable all optional behaviors.</summary>
    /// <remarks>Native: TVG_ENGINE_OPTION_NONE</remarks>
    None = 0,
    /// <summary>Uses the default rendering mode.</summary>
    /// <remarks>Native: TVG_ENGINE_OPTION_DEFAULT</remarks>
    Default = 1 << 0,
    /// <summary>Enables automatic partial (smart) rendering optimizations.</summary>
    /// <remarks>Native: TVG_ENGINE_OPTION_SMART_RENDER</remarks>
    SmartRender = 1 << 1,
}

/// <summary>
/// Enumeration indicating the method used in the masking of two objects - the target and the source.
/// Native: Tvg_Mask_Method
/// </summary>
public enum MaskMethod : uint
{
    /// <summary>No Masking is applied.</summary>
    /// <remarks>Native: TVG_MASK_METHOD_NONE</remarks>
    None = 0,
    /// <summary>Alpha Masking using the masking target's pixels as an alpha value.</summary>
    /// <remarks>Native: TVG_MASK_METHOD_ALPHA</remarks>
    Alpha,
    /// <summary>Alpha Masking using the complement to the masking target's pixels as an alpha value.</summary>
    /// <remarks>Native: TVG_MASK_METHOD_INVERSE_ALPHA</remarks>
    InverseAlpha,
    /// <summary>Alpha Masking using the grayscale (0.2126R + 0.7152G + 0.0722*B) of the masking target's pixels. @since 0.9</summary>
    /// <remarks>Native: TVG_MASK_METHOD_LUMA</remarks>
    Luma,
    /// <summary>Alpha Masking using the grayscale (0.2126R + 0.7152G + 0.0722*B) of the complement to the masking target's pixels. @since 0.11</summary>
    /// <remarks>Native: TVG_MASK_METHOD_INVERSE_LUMA</remarks>
    InverseLuma,
    /// <summary>Combines the target and source objects pixels using target alpha. (T * TA) + (S * (255 - TA)) @since 1.0</summary>
    /// <remarks>Native: TVG_MASK_METHOD_ADD</remarks>
    Add,
    /// <summary>Subtracts the source color from the target color while considering their respective target alpha. (T * TA) - (S * (255 - TA)) @since 1.0</summary>
    /// <remarks>Native: TVG_MASK_METHOD_SUBTRACT</remarks>
    Subtract,
    /// <summary>Computes the result by taking the minimum value between the target alpha and the source alpha and multiplies it with the target color. (T * min(TA, SA)) @since 1.0</summary>
    /// <remarks>Native: TVG_MASK_METHOD_INTERSECT</remarks>
    Intersect,
    /// <summary>Calculates the absolute difference between the target color and the source color multiplied by the complement of the target alpha. abs(T - S * (255 - TA)) @since 1.0</summary>
    /// <remarks>Native: TVG_MASK_METHOD_DIFFERENCE</remarks>
    Difference,
    /// <summary>Where multiple masks intersect, the highest transparency value is used. @since 1.0</summary>
    /// <remarks>Native: TVG_MASK_METHOD_LIGHTEN</remarks>
    Lighten,
    /// <summary>Where multiple masks intersect, the lowest transparency value is used. @since 1.0</summary>
    /// <remarks>Native: TVG_MASK_METHOD_DARKEN</remarks>
    Darken,
}

/// <summary>
/// Enumeration indicates the method used for blending paint. Please refer to the respective formulas for each method.
/// Native: Tvg_Blend_Method
/// </summary>
public enum BlendMethod : uint
{
    /// <summary>Perform the alpha blending(default). S if (Sa == 255), otherwise (Sa * S) + (255 - Sa) * D</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_NORMAL</remarks>
    Normal = 0,
    /// <summary>Takes the RGB channel values from 0 to 255 of each pixel in the top layer and multiples them with the values for the corresponding pixel from the bottom layer. (S * D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_MULTIPLY</remarks>
    Multiply,
    /// <summary>The values of the pixels in the two layers are inverted, multiplied, and then inverted again. (S + D) - (S * D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_SCREEN</remarks>
    Screen,
    /// <summary>Combines Multiply and Screen blend modes. (2 * S * D) if (2 * D &lt; Da), otherwise (Sa * Da) - 2 * (Da - S) * (Sa - D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_OVERLAY</remarks>
    Overlay,
    /// <summary>Creates a pixel that retains the smallest components of the top and bottom layer pixels. min(S, D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_DARKEN</remarks>
    Darken,
    /// <summary>Only has the opposite action of Darken Only. max(S, D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_LIGHTEN</remarks>
    Lighten,
    /// <summary>Divides the bottom layer by the inverted top layer. D / (255 - S)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_COLORDODGE</remarks>
    Colordodge,
    /// <summary>Divides the inverted bottom layer by the top layer, and then inverts the result. 255 - (255 - D) / S</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_COLORBURN</remarks>
    Colorburn,
    /// <summary>The same as Overlay but with the color roles reversed. (2 * S * D) if (S &lt; Sa), otherwise (Sa * Da) - 2 * (Da - S) * (Sa - D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_HARDLIGHT</remarks>
    Hardlight,
    /// <summary>The same as Overlay but with applying pure black or white does not result in pure black or white. (1 - 2 * S) * (D ^ 2) + (2 * S * D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_SOFTLIGHT</remarks>
    Softlight,
    /// <summary>Subtracts the bottom layer from the top layer or the other way around, to always get a non-negative value. (S - D) if (S > D), otherwise (D - S)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_DIFFERENCE</remarks>
    Difference,
    /// <summary>The result is twice the product of the top and bottom layers, subtracted from their sum. s + d - (2 * s * d)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_EXCLUSION</remarks>
    Exclusion,
    /// <summary>Combine with HSL(Sh + Ds + Dl) then convert it to RGB.</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_HUE</remarks>
    Hue,
    /// <summary>Combine with HSL(Dh + Ss + Dl) then convert it to RGB.</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_SATURATION</remarks>
    Saturation,
    /// <summary>Combine with HSL(Sh + Ss + Dl) then convert it to RGB.</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_COLOR</remarks>
    Color,
    /// <summary>Combine with HSL(Dh + Ds + Sl) then convert it to RGB.</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_LUMINOSITY</remarks>
    Luminosity,
    /// <summary>Simply adds pixel values of one layer with the other. (S + D)</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_ADD</remarks>
    Add,
    /// <summary>Used for intermediate composition. @since 1.0</summary>
    /// <remarks>Native: TVG_BLEND_METHOD_COMPOSITION</remarks>
    Composition = 255,
}

/// <summary>
/// Enumeration indicating the ThorVG object type value. ThorVG's drawing objects can return object type values, allowing you to identify the specific type of each object.
/// Native: Tvg_Type
/// </summary>
public enum PaintType : uint
{
    /// <summary>Undefined type.</summary>
    /// <remarks>Native: TVG_TYPE_UNDEF</remarks>
    Undef = 0,
    /// <summary>A shape type paint.</summary>
    /// <remarks>Native: TVG_TYPE_SHAPE</remarks>
    Shape,
    /// <summary>A scene type paint.</summary>
    /// <remarks>Native: TVG_TYPE_SCENE</remarks>
    Scene,
    /// <summary>A picture type paint.</summary>
    /// <remarks>Native: TVG_TYPE_PICTURE</remarks>
    Picture,
    /// <summary>A text type paint.</summary>
    /// <remarks>Native: TVG_TYPE_TEXT</remarks>
    Text,
    /// <summary>A linear gradient type.</summary>
    /// <remarks>Native: TVG_TYPE_LINEAR_GRAD</remarks>
    LinearGrad = 10,
    /// <summary>A radial gradient type.</summary>
    /// <remarks>Native: TVG_TYPE_RADIAL_GRAD</remarks>
    RadialGrad,
}

/// <summary>
/// Enumeration determining the ending type of a stroke in the open sub-paths.
/// Native: Tvg_Stroke_Cap
/// </summary>
public enum StrokeCap : uint
{
    /// <summary>The stroke ends exactly at each of the two endpoints of a sub-path. For zero length sub-paths no stroke is rendered.</summary>
    /// <remarks>Native: TVG_STROKE_CAP_BUTT</remarks>
    Butt = 0,
    /// <summary>The stroke is extended in both endpoints of a sub-path by a half circle, with a radius equal to the half of a stroke width. For zero length sub-paths a full circle is rendered.</summary>
    /// <remarks>Native: TVG_STROKE_CAP_ROUND</remarks>
    Round,
    /// <summary>The stroke is extended in both endpoints of a sub-path by a rectangle, with the width equal to the stroke width and the length equal to the half of the stroke width. For zero length sub-paths the square is rendered with the size of the stroke width.</summary>
    /// <remarks>Native: TVG_STROKE_CAP_SQUARE</remarks>
    Square,
}

/// <summary>
/// Enumeration specifying how to fill the area outside the gradient bounds.
/// Native: Tvg_Stroke_Join
/// </summary>
public enum StrokeJoin : uint
{
    /// <summary>The outer corner of the joined path segments is spiked. The spike is created by extension beyond the join point of the outer edges of the stroke until they intersect. In case the extension goes beyond the limit, the join style is converted to the Bevel style.</summary>
    /// <remarks>Native: TVG_STROKE_JOIN_MITER</remarks>
    Miter = 0,
    /// <summary>The outer corner of the joined path segments is rounded. The circular region is centered at the join point.</summary>
    /// <remarks>Native: TVG_STROKE_JOIN_ROUND</remarks>
    Round,
    /// <summary>The outer corner of the joined path segments is bevelled at the join point. The triangular region of the corner is enclosed by a straight line between the outer corners of each stroke.</summary>
    /// <remarks>Native: TVG_STROKE_JOIN_BEVEL</remarks>
    Bevel,
}

/// <summary>
/// Enumeration specifying how to fill the area outside the gradient bounds.
/// Native: Tvg_Stroke_Fill
/// </summary>
public enum StrokeFill : uint
{
    /// <summary>The remaining area is filled with the closest stop color.</summary>
    /// <remarks>Native: TVG_STROKE_FILL_PAD</remarks>
    Pad = 0,
    /// <summary>The gradient pattern is reflected outside the gradient area until the expected region is filled.</summary>
    /// <remarks>Native: TVG_STROKE_FILL_REFLECT</remarks>
    Reflect,
    /// <summary>The gradient pattern is repeated continuously beyond the gradient area until the expected region is filled.</summary>
    /// <remarks>Native: TVG_STROKE_FILL_REPEAT</remarks>
    Repeat,
}

/// <summary>
/// Enumeration specifying the algorithm used to establish which parts of the shape are treated as the inside of the shape.
/// Native: Tvg_Fill_Rule
/// </summary>
public enum FillRule : uint
{
    /// <summary>A line from the point to a location outside the shape is drawn. The intersections of the line with the path segment of the shape are counted. Starting from zero, if the path segment of the shape crosses the line clockwise, one is added, otherwise one is subtracted. If the resulting sum is non zero, the point is inside the shape.</summary>
    /// <remarks>Native: TVG_FILL_RULE_NON_ZERO</remarks>
    NonZero = 0,
    /// <summary>A line from the point to a location outside the shape is drawn and its intersections with the path segments of the shape are counted. If the number of intersections is an odd number, the point is inside the shape.</summary>
    /// <remarks>Native: TVG_FILL_RULE_EVEN_ODD</remarks>
    EvenOdd,
}

/// <summary>
/// A data structure storing the information about the color and its relative position inside the gradient bounds.
/// Native: Tvg_Text_Wrap
/// </summary>
public enum TextWrap : uint
{
    /// <summary>Do not wrap text. Text is rendered on a single line and may overflow the bounding area.</summary>
    /// <remarks>Native: TVG_TEXT_WRAP_NONE</remarks>
    None = 0,
    /// <summary>Wrap at the character level. If a word cannot fit, it is broken into individual characters to fit the line.</summary>
    /// <remarks>Native: TVG_TEXT_WRAP_CHARACTER</remarks>
    Character,
    /// <summary>Wrap at the word level. Words that do not fit are moved to the next line.</summary>
    /// <remarks>Native: TVG_TEXT_WRAP_WORD</remarks>
    Word,
    /// <summary>Smart choose wrapping method: word wrap first, falling back to character wrap if a word does not fit.</summary>
    /// <remarks>Native: TVG_TEXT_WRAP_SMART</remarks>
    Smart,
    /// <summary>Truncate overflowing text and append an ellipsis ("...") at the end. Typically used for single-line labels.</summary>
    /// <remarks>Native: TVG_TEXT_WRAP_ELLIPSIS</remarks>
    Ellipsis,
    /// <summary>Reserved. No Support.</summary>
    /// <remarks>Native: TVG_TEXT_WRAP_HYPHENATION</remarks>
    Hyphenation,
}

